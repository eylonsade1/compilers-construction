;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 48

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL, 0
db T_BOOL, 1
MAKE_LITERAL_STRING 119, 104, 97, 116, 101, 118, 101, 114
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_RATIONAL(0, 1)
MAKE_LITERAL_RATIONAL(1, 1)
MAKE_LITERAL_RATIONAL(-1, 1)
MAKE_LITERAL_RATIONAL(2, 1)
MAKE_LITERAL_RATIONAL(3, 1)
MAKE_LITERAL_RATIONAL(4, 1)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+72], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+160], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+296], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+280], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+256], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+104], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+352], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+288], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+360], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+328], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+336], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+344], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+232], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+368], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+96], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+200], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+152], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+136], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+8], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+0], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+40], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+32], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+272], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+128], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+184], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+80], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+88], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+112], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+304], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+312], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+64], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+64]
push rax
mov rax, qword [fvar_tbl+112]
push rax
mov rax, qword [fvar_tbl+88]
push rax
mov rax, qword [fvar_tbl+80]
push rax
mov rax, qword [fvar_tbl+256]
push rax
mov rax, rsp
mov rax, 6
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode7)
jmp Lcont7
Lcode7:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+23
push rax
mov rax, const_tbl+23
push rax
push 3
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode6)
jmp Lcont6
Lcode6:
push rbp
mov rbp, rsp
push rbx
MALLOC rbx, 8
mov rax, qword [rbp+32]
mov qword [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp+32], rax
mov rax, SOB_VOID_ADDRESS
push rbx
MALLOC rbx, 8
mov rax, qword [rbp+40]
mov qword [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp+40], rax
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode2)
jmp Lcont2
Lcode2:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse1
mov rax, const_tbl+1
jmp Lexit1
Lelse1:
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 4; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit1:
leave
ret
Lcont2:
push rax
mov rax, qword [rbp+32]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode4)
jmp Lcont4
Lcode4:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse3
mov rax, const_tbl+1
jmp Lexit3
Lelse3:
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [rbp+32]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit3:
leave
ret
Lcont4:
push rax
mov rax, qword [rbp+40]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode5)
jmp Lcont5
Lcode5:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 32
MAKE_LIST_LOOP5:
cmp rdx,rax
je END_MAKE_LIST_LOOP5
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP5
END_MAKE_LIST_LOOP5:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont5:
leave
ret
Lcont6:
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont7:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+240], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode9)
jmp Lcont9
Lcode9:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+1
push rax
mov rax, qword [rbp+48]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rax, qword [fvar_tbl+136]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse8
mov rax, qword [rbp+40]
jmp Lexit8
Lelse8:
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+48]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+88]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+48]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+80]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rax, qword [rbp+32]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
push 4
mov rax, qword [fvar_tbl+168]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit8:
leave
ret
Lcont9:
mov qword [fvar_tbl+168], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode11)
jmp Lcont11
Lcode11:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+1
push rax
mov rax, qword [rbp+48]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rax, qword [fvar_tbl+136]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse10
mov rax, qword [rbp+40]
jmp Lexit10
Lelse10:
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+48]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+88]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+40]
push rax
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 4
push rax
mov rax, qword [fvar_tbl+176]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+48]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+80]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rax, qword [rbp+32]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit10:
leave
ret
Lcont11:
mov qword [fvar_tbl+176], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode15)
jmp Lcont15
Lcode15:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 32
MAKE_LIST_LOOP15:
cmp rdx,rax
je END_MAKE_LIST_LOOP15
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP15
END_MAKE_LIST_LOOP15:
push SOB_NIL_ADDRESS
mov rax, const_tbl+1
push rax
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rax, qword [fvar_tbl+136]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse14
mov rax, qword [rbp+32]
jmp Lexit14
Lelse14:
push SOB_NIL_ADDRESS
mov rax, const_tbl+1
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+80]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rax, qword [fvar_tbl+136]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse13
mov rax, qword [rbp+32]
jmp Lexit13
Lelse13:
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+80]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+280]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse12
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+80]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+88]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+80]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+80]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rax, qword [fvar_tbl+120]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rax, qword [fvar_tbl+112]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit12
Lelse12:
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+88]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [fvar_tbl+80]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rax, qword [fvar_tbl+120]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rax, qword [fvar_tbl+112]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit12:
Lexit13:
Lexit14:
leave
ret
Lcont15:
mov qword [fvar_tbl+120], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+112]
push rax
mov rax, qword [fvar_tbl+176]
push rax
mov rax, qword [fvar_tbl+256]
push rax
mov rax, rsp
mov rax, 4
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode19)
jmp Lcont19
Lcode19:
push rbp
mov rbp, rsp
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode18)
jmp Lcont18
Lcode18:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 24
MAKE_LIST_LOOP18:
cmp rdx,rax
je END_MAKE_LIST_LOOP18
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP18
END_MAKE_LIST_LOOP18:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, const_tbl+1
push rax
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode17)
jmp Lcont17
Lcode17:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse16
mov rax, qword [rbp+32]
jmp Lexit16
Lelse16:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, qword [rbp+40]
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
push 4
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit16:
leave
ret
Lcont17:
push rax
push 4
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont18:
leave
ret
Lcont19:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+56], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode20)
jmp Lcont20
Lcode20:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 24
MAKE_LIST_LOOP20:
cmp rdx,rax
je END_MAKE_LIST_LOOP20
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP20
END_MAKE_LIST_LOOP20:
mov rax, qword [rbp+32]
leave
ret
Lcont20:
mov qword [fvar_tbl+216], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+88]
push rax
mov rax, qword [fvar_tbl+280]
push rax
mov rax, qword [fvar_tbl+256]
push rax
mov rax, rsp
mov rax, 4
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode25)
jmp Lcont25
Lcode25:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+23
push rax
push 2
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode24)
jmp Lcont24
Lcode24:
push rbp
mov rbp, rsp
push rbx
MALLOC rbx, 8
mov rax, qword [rbp+32]
mov qword [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp+32], rax
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode23)
jmp Lcont23
Lcode23:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit22
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse21
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 2
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit21
Lelse21:
mov rax, const_tbl+2
Lexit21:
Lexit22:
leave
ret
Lcont23:
push rax
mov rax, qword [rbp+32]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp+32]
mov rax, qword [rax]
leave
ret
Lcont24:
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont25:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+224], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode27)
jmp Lcont27
Lcode27:
push rbp
mov rbp, rsp
mov rax, qword [rbp+32]
cmp rax, SOB_FALSE_ADDRESS
je Lelse26
mov rax, const_tbl+2
jmp Lexit26
Lelse26:
mov rax, const_tbl+4
Lexit26:
leave
ret
Lcont27:
mov qword [fvar_tbl+248], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+232]
push rax
mov rax, qword [fvar_tbl+80]
push rax
mov rax, qword [fvar_tbl+256]
push rax
mov rax, rsp
mov rax, 4
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode30)
jmp Lcont30
Lcode30:
push rbp
mov rbp, rsp
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode29)
jmp Lcont29
Lcode29:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 32
MAKE_LIST_LOOP29:
cmp rdx,rax
je END_MAKE_LIST_LOOP29
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP29
END_MAKE_LIST_LOOP29:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse28
push SOB_NIL_ADDRESS
mov rax, const_tbl+32
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit28
Lelse28:
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit28:
leave
ret
Lcont29:
leave
ret
Lcont30:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+232], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+256]
push rax
mov rax, qword [fvar_tbl+88]
push rax
mov rax, qword [fvar_tbl+80]
push rax
mov rax, qword [fvar_tbl+32]
push rax
mov rax, qword [fvar_tbl+40]
push rax
mov rax, qword [fvar_tbl+24]
push rax
mov rax, qword [fvar_tbl+0]
push rax
mov rax, qword [fvar_tbl+8]
push rax
mov rax, qword [fvar_tbl+240]
push rax
mov rax, qword [fvar_tbl+168]
push rax
mov rax, qword [fvar_tbl+152]
push rax
mov rax, qword [fvar_tbl+296]
push rax
mov rax, qword [fvar_tbl+160]
push rax
mov rax, rsp
mov rax, 14
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode50)
jmp Lcont50
Lcode50:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode36)
jmp Lcont36
Lcode36:
push rbp
mov rbp, rsp
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode35)
jmp Lcont35
Lcode35:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse31
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
jmp Lexit31
Lelse31:
mov rax, const_tbl+2
Lexit31:
cmp rax, SOB_FALSE_ADDRESS
je Lelse34
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit34
Lelse34:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse32
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
jmp Lexit32
Lelse32:
mov rax, const_tbl+2
Lexit32:
cmp rax, SOB_FALSE_ADDRESS
je Lelse33
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit33
Lelse33:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit33:
Lexit34:
leave
ret
Lcont35:
leave
ret
Lcont36:
push rax
push 2
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode49)
jmp Lcont49
Lcode49:
push rbp
mov rbp, rsp
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode37)
jmp Lcont37
Lcode37:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 24
MAKE_LIST_LOOP37:
cmp rdx,rax
je END_MAKE_LIST_LOOP37
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP37
END_MAKE_LIST_LOOP37:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, const_tbl+34
push rax
push SOB_NIL_ADDRESS
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 5; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 4
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont37:
mov qword [fvar_tbl+8], rax
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode38)
jmp Lcont38
Lcode38:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 24
MAKE_LIST_LOOP38:
cmp rdx,rax
je END_MAKE_LIST_LOOP38
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP38
END_MAKE_LIST_LOOP38:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, const_tbl+51
push rax
push SOB_NIL_ADDRESS
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 6; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 4
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont38:
mov qword [fvar_tbl+0], rax
mov rax, SOB_VOID_ADDRESS
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 7; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [rbp+32]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 2
push rax
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode41)
jmp Lcont41
Lcode41:
push rbp
mov rbp, rsp
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode40)
jmp Lcont40
Lcode40:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 32
MAKE_LIST_LOOP40:
cmp rdx,rax
je END_MAKE_LIST_LOOP40
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP40
END_MAKE_LIST_LOOP40:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 2 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 12; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse39
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, const_tbl+51
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit39
Lelse39:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, qword [rbp+32]
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
push 4
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 2 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit39:
leave
ret
Lcont40:
leave
ret
Lcont41:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+24], rax
mov rax, SOB_VOID_ADDRESS
push SOB_NIL_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode47)
jmp Lcont47
Lcode47:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+23
push rax
push 2
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode46)
jmp Lcont46
Lcode46:
push rbp
mov rbp, rsp
push rbx
MALLOC rbx, 8
mov rax, qword [rbp+32]
mov qword [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp+32], rax
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode44)
jmp Lcont44
Lcode44:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 3 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 12; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit43
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 3 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 10; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse42
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 3 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 11; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 3 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 10; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit42
Lelse42:
mov rax, const_tbl+2
Lexit42:
Lexit43:
leave
ret
Lcont44:
push rax
mov rax, qword [rbp+32]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode45)
jmp Lcont45
Lcode45:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 32
MAKE_LIST_LOOP45:
cmp rdx,rax
je END_MAKE_LIST_LOOP45
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP45
END_MAKE_LIST_LOOP45:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont45:
leave
ret
Lcont46:
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont47:
push rax
push 2
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode48)
jmp Lcont48
Lcode48:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 8; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [rbp+32]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+40], rax
mov rax, SOB_VOID_ADDRESS
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 9; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rax, qword [rbp+32]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+32], rax
mov rax, SOB_VOID_ADDRESS
leave
ret
Lcont48:
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont49:
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont50:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+256]
push rax
mov rax, qword [fvar_tbl+8]
push rax
mov rax, qword [fvar_tbl+64]
push rax
mov rax, rsp
mov rax, 4
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode53)
jmp Lcont53
Lcode53:
push rbp
mov rbp, rsp
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode52)
jmp Lcont52
Lcode52:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 32
MAKE_LIST_LOOP52:
cmp rdx,rax
je END_MAKE_LIST_LOOP52
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP52
END_MAKE_LIST_LOOP52:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse51
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, const_tbl+68
push rax
mov rax, rsp
mov rax, 3
push rax
mov rax, qword [fvar_tbl+0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, const_tbl+34
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit51
Lelse51:
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, const_tbl+68
push rax
mov rax, rsp
mov rax, 3
push rax
mov rax, qword [fvar_tbl+0]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit51:
leave
ret
Lcont52:
leave
ret
Lcont53:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+16], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+40]
push rax
mov rax, qword [fvar_tbl+32]
push rax
mov rax, qword [fvar_tbl+88]
push rax
mov rax, qword [fvar_tbl+80]
push rax
mov rax, qword [fvar_tbl+248]
push rax
mov rax, qword [fvar_tbl+256]
push rax
mov rax, rsp
mov rax, 7
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode60)
jmp Lcont60
Lcode60:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+23
push rax
push 2
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode59)
jmp Lcont59
Lcode59:
push rbp
mov rbp, rsp
push rbx
MALLOC rbx, 8
mov rax, qword [rbp+32]
mov qword [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp+32], rax
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode57)
jmp Lcont57
Lcode57:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit56
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 4; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse55
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 5; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse54
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit54
Lelse54:
mov rax, const_tbl+2
Lexit54:
jmp Lexit55
Lelse55:
mov rax, const_tbl+2
Lexit55:
Lexit56:
leave
ret
Lcont57:
push rax
mov rax, qword [rbp+32]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode58)
jmp Lcont58
Lcode58:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 32
MAKE_LIST_LOOP58:
cmp rdx,rax
je END_MAKE_LIST_LOOP58
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP58
END_MAKE_LIST_LOOP58:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont58:
leave
ret
Lcont59:
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont60:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+48], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+88]
push rax
mov rax, qword [fvar_tbl+80]
push rax
mov rax, qword [fvar_tbl+256]
push rax
mov rax, qword [fvar_tbl+184]
push rax
mov rax, rsp
mov rax, 5
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode66)
jmp Lcont66
Lcode66:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+23
push rax
push 2
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode65)
jmp Lcont65
Lcode65:
push rbp
mov rbp, rsp
push rbx
MALLOC rbx, 8
mov rax, qword [rbp+32]
mov qword [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp+32], rax
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode62)
jmp Lcont62
Lcode62:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse61
mov rax, qword [rbp+32]
jmp Lexit61
Lelse61:
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit61:
leave
ret
Lcont62:
push rax
mov rax, qword [rbp+32]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode64)
jmp Lcont64
Lcode64:
push rbp
mov rbp, rsp
mov rcx, rbp
add rcx, 24
mov rbx,qword [rcx]
imul rbx, 8
add rcx, rbx
mov rax, rcx
sub rax, 8
mov rdx, rbp
add rdx, 24
MAKE_LIST_LOOP64:
cmp rdx,rax
je END_MAKE_LIST_LOOP64
push rax
mov rax, qword [rax]
mov rcx, qword [rcx]
MAKE_PAIR(rbx, rax, rcx)
pop rax
mov qword [rax], rbx
mov rcx, rax
sub rax, 8
jmp MAKE_LIST_LOOP64
END_MAKE_LIST_LOOP64:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse63
mov rax, const_tbl+34
jmp Lexit63
Lelse63:
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit63:
leave
ret
Lcont64:
leave
ret
Lcont65:
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont66:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+184], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode68)
jmp Lcont68
Lcode68:
push rbp
mov rbp, rsp
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode67)
jmp Lcont67
Lcode67:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+34
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont67:
leave
ret
Lcont68:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+376], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+128]
push rax
mov rax, qword [fvar_tbl+40]
push rax
mov rax, qword [fvar_tbl+296]
push rax
mov rax, rsp
mov rax, 4
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode71)
jmp Lcont71
Lcode71:
push rbp
mov rbp, rsp
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode70)
jmp Lcont70
Lcode70:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse69
push SOB_NIL_ADDRESS
mov rax, const_tbl+51
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit69
Lelse69:
mov rax, const_tbl+2
Lexit69:
leave
ret
Lcont70:
leave
ret
Lcont71:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+192], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+296]
push rax
mov rax, qword [fvar_tbl+160]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode74)
jmp Lcont74
Lcode74:
push rbp
mov rbp, rsp
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode73)
jmp Lcont73
Lcode73:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
jne Lexit72
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
push 2
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit72:
leave
ret
Lcont73:
leave
ret
Lcont74:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+264], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+8]
push rax
mov rax, qword [fvar_tbl+168]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode77)
jmp Lcont77
Lcode77:
push rbp
mov rbp, rsp
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode76)
jmp Lcont76
Lcode76:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, const_tbl+34
push rax
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode75)
jmp Lcont75
Lcode75:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+51
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont75:
push rax
push 4
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont76:
leave
ret
Lcont77:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+208], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+112]
push rax
mov rax, qword [fvar_tbl+16]
push rax
mov rax, qword [fvar_tbl+32]
push rax
mov rax, qword [fvar_tbl+328]
push rax
mov rax, qword [fvar_tbl+336]
push rax
mov rax, rsp
mov rax, 6
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode82)
jmp Lcont82
Lcode82:
push rbp
mov rbp, rsp
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode81)
jmp Lcont81
Lcode81:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+23
push rax
push 2
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode80)
jmp Lcont80
Lcode80:
push rbp
mov rbp, rsp
push rbx
MALLOC rbx, 8
mov rax, qword [rbp+32]
mov qword [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp+32], rax
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode79)
jmp Lcont79
Lcode79:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+34
push rax
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 2 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse78
mov rax, qword [rbp+40]
jmp Lexit78
Lelse78:
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 2 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 2 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 4; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
mov rax, const_tbl+51
push rax
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 2 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit78:
leave
ret
Lcont79:
push rax
mov rax, qword [rbp+32]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
push SOB_NIL_ADDRESS
mov rax, const_tbl+1
push rax
push SOB_NIL_ADDRESS
mov rax, const_tbl+51
push rax
push SOB_NIL_ADDRESS
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rax, qword [rbp+32]
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont80:
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont81:
leave
ret
Lcont82:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+320], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

push SOB_NIL_ADDRESS
mov rax, qword [fvar_tbl+96]
push rax
mov rax, qword [fvar_tbl+88]
push rax
mov rax, qword [fvar_tbl+80]
push rax
mov rax, qword [fvar_tbl+136]
push rax
mov rax, qword [fvar_tbl+352]
push rax
mov rax, qword [fvar_tbl+104]
push rax
mov rax, qword [fvar_tbl+280]
push rax
mov rax, qword [fvar_tbl+160]
push rax
mov rax, qword [fvar_tbl+296]
push rax
mov rax, qword [fvar_tbl+320]
push rax
mov rax, qword [fvar_tbl+40]
push rax
mov rax, rsp
mov rax, 12
push rax
mov rcx, SOB_NIL_ADDRESS
MAKE_CLOSURE(rax, rcx, Lcode96)
jmp Lcont96
Lcode96:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, const_tbl+23
push rax
push 2
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode95)
jmp Lcont95
Lcode95:
push rbp
mov rbp, rsp
push rbx
MALLOC rbx, 8
mov rax, qword [rbp+32]
mov qword [rbx], rax
mov rax, rbx
pop rbx
mov qword [rbp+32], rax
mov rax, SOB_VOID_ADDRESS
EXTAND_ENV_RCX
MAKE_CLOSURE(rax, rcx, Lcode94)
jmp Lcont94
Lcode94:
push rbp
mov rbp, rsp
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse83
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 2; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
jmp Lexit83
Lelse83:
mov rax, const_tbl+2
Lexit83:
cmp rax, SOB_FALSE_ADDRESS
je Lelse93
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit93
Lelse93:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse84
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 3; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
jmp Lexit84
Lelse84:
mov rax, const_tbl+2
Lexit84:
cmp rax, SOB_FALSE_ADDRESS
je Lelse92
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit92
Lelse92:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 5; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse85
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 5; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
jmp Lexit85
Lelse85:
mov rax, const_tbl+2
Lexit85:
cmp rax, SOB_FALSE_ADDRESS
je Lelse91
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 10; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 10; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit91
Lelse91:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 4; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse86
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 4; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
jmp Lexit86
Lelse86:
mov rax, const_tbl+2
Lexit86:
cmp rax, SOB_FALSE_ADDRESS
je Lelse90
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 8; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 8; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
mov rax, rsp
mov rax, 3
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse87
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 9; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 9; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit87
Lelse87:
mov rax, const_tbl+2
Lexit87:
jmp Lexit90
Lelse90:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 6; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
cmp rax, SOB_FALSE_ADDRESS
je Lelse88
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 6; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
jmp Lexit88
Lelse88:
mov rax, const_tbl+2
Lexit88:
cmp rax, SOB_FALSE_ADDRESS
je Lelse89
push SOB_NIL_ADDRESS
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push SOB_NIL_ADDRESS
mov rax, qword [rbp+32]
push rax
mov rax, rsp
mov rax, 2
push rax
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 1; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 0 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 0; rbx = minor
GET_N_ITEM rax, rdx, rbx
mov rax, qword [rax]
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
jmp Lexit89
Lelse89:
push SOB_NIL_ADDRESS
mov rax, qword [rbp+40]
push rax
mov rax, qword [rbp+32]
push rax
push 3
mov rbx, qword [rbp+16] ; rbx = env
mov rcx, 1 ;rcx = major
GET_N_ITEM rdx, rbx, rcx ; rdx = specific env
mov rbx, 7; rbx = minor
GET_N_ITEM rax, rdx, rbx
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
Lexit89:
Lexit90:
Lexit91:
Lexit92:
Lexit93:
leave
ret
Lcont94:
push rax
mov rax, qword [rbp+32]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp+32]
mov rax, qword [rax]
leave
ret
Lcont95:
CLOSURE_ENV rbx, rax
push rbx
push qword [rbp+8]
push rax
FIX_STACK
pop rax
CLOSURE_CODE rbx, rax
jmp rbx
leave
ret
Lcont96:
CLOSURE_ENV rbx, rax
push rbx
CLOSURE_CODE rbx, rax
call rbx
add rsp, 8 ; pop env

    pop rbx ; pop arg count

    lea rsp , [rsp + 8*rbx]
mov qword [fvar_tbl+144], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

mov rax, const_tbl+51
cmp rax, SOB_FALSE_ADDRESS
jne Lexit97
mov rax, const_tbl+85
Lexit97:
cmp rax, SOB_FALSE_ADDRESS
je Lelse99
mov rax, const_tbl+102
cmp rax, SOB_FALSE_ADDRESS
jne Lexit98
mov rax, const_tbl+119
Lexit98:
jmp Lexit99
Lelse99:
mov rax, const_tbl+2
Lexit99:

	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 3*8
   mov rax, 0

   ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rax, qword [rsi+TYPE_SIZE]
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rax, qword [rsi+TYPE_SIZE+WORD_SIZE]
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	MAKE_PAIR(rax, rsi, rdi)
         pop rbp
         ret

set_car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi+TYPE_SIZE], rdi
mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

set_cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi+TYPE_SIZE+WORD_SIZE], rdi
mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

apply:
       push rbp
       mov rbp, rsp 
       APPLY_MACRO
         pop rbp
         ret